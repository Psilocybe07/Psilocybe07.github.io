// [Previous head section and styles remain the same, adding FPS display style]
<style>
    /* Add to existing styles */
    #fpsCounter {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
    }
</style>
<div id="fpsCounter">FPS: 60</div>

// [Previous script variables remain the same, adding new ones]
<script>
let lastUpdateTime = 0;
const UPDATE_INTERVAL = 50; // Send position updates every 50ms
let bulletPool;
let fpsText;
let lastFpsUpdate = 0;

// Add to the create function:
function create() {
    // [Previous create code remains the same]
    
    // Initialize bullet pool
    bulletPool = this.add.group({
        classType: Phaser.Physics.Arcade.Sprite,
        defaultKey: 'bullet',
        maxSize: 30, // Maximum bullets in the pool
        runChildUpdate: true
    });

    // Create 30 inactive bullets
    for (let i = 0; i < 30; i++) {
        const bullet = bulletPool.create(0, 0, 'bullet');
        bullet.setActive(false);
        bullet.setVisible(false);
    }

    // Add FPS text
    fpsText = this.add.text(10, 10, 'FPS: 0', { fontSize: '16px', fill: '#fff' });
}

// Replace the shoot function with an optimized version:
function shoot(pointer) {
    if (!localPlayer || ammoCount <= 0 || isReloading) return;
    
    const currentTime = Date.now();
    if (currentTime - lastShootTime < 250) return;
    lastShootTime = currentTime;

    // Get bullet from pool
    const bullet = bulletPool.get();
    if (!bullet) return; // No bullets available in pool

    bullet.setActive(true)
        .setVisible(true)
        .setPosition(localPlayer.x, localPlayer.y);
    
    bullet.setTint(playerInfo[playerId].color);
    bullet.owner = playerId;
    
    const angle = Phaser.Math.Angle.Between(
        localPlayer.x, localPlayer.y,
        pointer.x, pointer.y
    );
    
    const speed = 500;
    bullet.setVelocity(
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
    );

    // Broadcast bullet only to nearby players
    Object.values(connections).forEach(conn => {
        const otherPlayer = players[conn.peer];
        if (otherPlayer && Phaser.Math.Distance.Between(
            localPlayer.x, localPlayer.y,
            otherPlayer.x, otherPlayer.y
        ) < 800) {
            conn.send({
                type: 'shoot',
                x: localPlayer.x,
                y: localPlayer.y,
                angle: angle,
                color: playerInfo[playerId].color,
                owner: playerId
            });
        }
    });

    ammoCount--;
    updateAmmoCount();

    // Return bullet to pool after 1 second
    this.time.delayedCall(1000, () => {
        bullet.setActive(false).setVisible(false);
    });
}

// Optimize the update function:
function update(time, delta) {
    if (!localPlayer) return;

    // Update FPS counter every 500ms
    if (time - lastFpsUpdate > 500) {
        const fps = Math.round(1000 / delta);
        fpsText.setText(`FPS: ${fps}`);
        document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
        lastFpsUpdate = time;
    }

    // Handle movement
    const speed = 200;
    let velocity = new Phaser.Math.Vector2(0, 0);

    if (keys.left.isDown) velocity.x = -speed;
    if (keys.right.isDown) velocity.x = speed;
    if (keys.up.isDown) velocity.y = -speed;
    if (keys.down.isDown) velocity.y = speed;

    velocity.normalize();
    velocity.scale(speed);
    localPlayer.setVelocity(velocity.x, velocity.y);

    // Update rotation only if mouse moved
    if (this.input.activePointer.movementX !== 0 || this.input.activePointer.movementY !== 0) {
        localPlayer.rotation = Phaser.Math.Angle.Between(
            localPlayer.x, localPlayer.y,
            this.input.activePointer.x, this.input.activePointer.y
        );
    }

    // Update name text position
    if (playerNameText) {
        playerNameText.x = localPlayer.x - playerNameText.width / 2;
        playerNameText.y = localPlayer.y - 40;
    }

    // Handle reload
    if (keys.reload.isDown && !isReloading) {
        reload();
    }

    // Throttle position updates
    if (time - lastUpdateTime > UPDATE_INTERVAL) {
        Object.values(connections).forEach(conn => {
            const otherPlayer = players[conn.peer];
            // Only send updates to nearby players
            if (!otherPlayer || Phaser.Math.Distance.Between(
                localPlayer.x, localPlayer.y,
                otherPlayer.x, otherPlayer.y
            ) < 800) {
                conn.send({
                    type: 'position',
                    x: localPlayer.x,
                    y: localPlayer.y,
                    playerInfo: playerInfo[playerId]
                });
            }
        });
        lastUpdateTime = time;
    }
}

// Optimize the handleRemoteShot function:
function handleRemoteShot(data) {
    const bullet = bulletPool.get();
    if (!bullet) return;

    bullet.setActive(true)
        .setVisible(true)
        .setPosition(data.x, data.y)
        .setTint(data.color);
    
    bullet.owner = data.owner;
    
    const speed = 500;
    bullet.setVelocity(
        Math.cos(data.angle) * speed,
        Math.sin(data.angle) * speed
    );

    this.time.delayedCall(1000, () => {
        bullet.setActive(false).setVisible(false);
    });
}

// Add cleanup function for bullets
function cleanup() {
    bulletPool.getChildren().forEach(bullet => {
        if (!bullet.active) return;
        
        // Check if bullet is out of bounds
        if (bullet.x < 0 || bullet.x > 800 || bullet.y < 0 || bullet.y > 600) {
            bullet.setActive(false).setVisible(false);
        }
    });
}
</script>
